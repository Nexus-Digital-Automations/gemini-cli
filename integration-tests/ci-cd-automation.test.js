/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { TestRig } from './test-helper.js';
import { spawn, execSync as _execSync } from 'node:child_process';
import {
  writeFileSync,
  readFileSync as _readFileSync,
  existsSync as _existsSync,
  mkdirSync,
  unlinkSync as _unlinkSync,
} from 'node:fs';
import { join, dirname as _dirname } from 'node:path';
import { performance as _performance } from 'node:perf_hooks';
/**
 * CI/CD Integration and Test Automation Suite
 *
 * Tests continuous integration pipelines, automated deployment scenarios,
 * test orchestration, failure recovery, and integration with various
 * CI/CD platforms and toolchains.
 */
describe('CI/CD Integration & Test Automation', () => {
  let rig;
  const taskManagerPath =
    '/Users/jeremyparker/infinite-continue-stop-hook/taskmanager-api.js';
  beforeEach(async () => {
    rig = new TestRig();
    rig.setup('ci-cd-automation');
  });
  afterEach(async () => {
    await rig.cleanup();
    // Clean up any CI environment variables
    delete process.env.CI;
    delete process.env.GITHUB_ACTIONS;
    delete process.env.BUILD_NUMBER;
    delete process.env.BRANCH_NAME;
    delete process.env.COMMIT_SHA;
  });
  /**
   * CI Pipeline Integration Tests
   * Tests integration with continuous integration systems
   */
  describe('CI Pipeline Integration', () => {
    it('should integrate with GitHub Actions workflow', async () => {
      // Simulate GitHub Actions environment
      process.env.CI = 'true';
      process.env.GITHUB_ACTIONS = 'true';
      process.env.GITHUB_WORKFLOW = 'Autonomous Task Management Tests';
      process.env.GITHUB_RUN_NUMBER = '123';
      process.env.GITHUB_SHA = 'abc123def456';
      process.env.GITHUB_REF = 'refs/heads/feature/autonomous-testing';
      console.log('Simulating GitHub Actions CI pipeline...');
      // Create CI configuration files
      const workflowDir = join(rig.testDir, '.github', 'workflows');
      mkdirSync(workflowDir, { recursive: true });
      const workflowConfig = {
        name: 'Autonomous Task Management CI',
        on: {
          push: { branches: ['main', 'feature/*'] },
          pull_request: { branches: ['main'] },
        },
        jobs: {
          test: {
            'runs-on': 'ubuntu-latest',
            steps: [
              { uses: 'actions/checkout@v3' },
              { uses: 'actions/setup-node@v3', with: { 'node-version': '20' } },
              { run: 'npm ci' },
              { run: 'npm run test:integration:autonomous' },
              { run: 'npm run test:performance' },
            ],
          },
        },
      };
      writeFileSync(
        join(workflowDir, 'autonomous-ci.yml'),
        `# Auto-generated by autonomous task management system\n${JSON.stringify(workflowConfig, null, 2)}`,
      );
      // Initialize CI agent
      const ciAgent = 'GITHUB_ACTIONS_AGENT';
      const initResult = await execTaskManagerCommand('initialize', [ciAgent]);
      expect(initResult.success).toBe(true);
      // Create CI-specific feature for testing pipeline
      const ciFeature = {
        title: 'CI/CD Pipeline - Automated Integration Testing',
        description:
          'Comprehensive automated testing pipeline with GitHub Actions integration, parallel test execution, and automated reporting',
        business_value:
          'Ensures code quality and reduces manual testing overhead through automated CI/CD pipeline',
        category: 'enhancement',
        metadata: {
          ci_environment: 'github-actions',
          workflow_run: process.env.GITHUB_RUN_NUMBER,
          commit_sha: process.env.GITHUB_SHA,
          branch: process.env.GITHUB_REF?.replace('refs/heads/', ''),
          automated: true,
        },
      };
      const featureResult = await execTaskManagerCommand('suggest-feature', [
        JSON.stringify(ciFeature),
      ]);
      expect(featureResult.success).toBe(true);
      // Auto-approve CI features (as would happen in automated pipeline)
      const approveResult = await execTaskManagerCommand('approve-feature', [
        featureResult.feature.id,
        JSON.stringify({
          approved_by: 'ci-automation',
          notes: 'Auto-approved by GitHub Actions CI pipeline',
        }),
      ]);
      expect(approveResult.success).toBe(true);
      // Generate tasks for CI pipeline
      const taskGenResult = await execTaskManagerCommand(
        'create-task-from-feature',
        [
          featureResult.feature.id,
          JSON.stringify({
            created_by: ciAgent,
            priority: 'high',
            metadata: {
              ci_generated: true,
              pipeline_id: process.env.GITHUB_RUN_NUMBER,
            },
          }),
        ],
      );
      expect(taskGenResult.success).toBe(true);
      expect(taskGenResult.task.metadata.ci_generated).toBe(true);
      // Verify CI integration statistics
      const stats = await execTaskManagerCommand(
        'get-initialization-stats',
        [],
      );
      expect(stats.success).toBe(true);
      console.log('GitHub Actions integration verified successfully');
    }, 30000);
    it('should handle CI environment detection and adaptation', async () => {
      const ciEnvironments = [
        {
          name: 'Jenkins',
          env: {
            CI: 'true',
            JENKINS_URL: 'http://jenkins.example.com',
            BUILD_NUMBER: '456',
          },
        },
        {
          name: 'GitLab CI',
          env: {
            CI: 'true',
            GITLAB_CI: 'true',
            CI_PIPELINE_ID: '789',
            CI_COMMIT_SHA: 'def456abc',
          },
        },
        {
          name: 'Azure DevOps',
          env: {
            TF_BUILD: 'true',
            BUILD_BUILDNUMBER: '101112',
            SYSTEM_TEAMPROJECT: 'autonomous-tasks',
          },
        },
        {
          name: 'CircleCI',
          env: {
            CI: 'true',
            CIRCLECI: 'true',
            CIRCLE_BUILD_NUM: '131415',
            CIRCLE_SHA1: 'ghi789jkl',
          },
        },
      ];
      for (const ciEnv of ciEnvironments) {
        console.log(`Testing ${ciEnv.name} environment detection...`);
        // Set CI environment variables
        Object.entries(ciEnv.env).forEach(([key, value]) => {
          process.env[key] = value;
        });
        // Initialize agent in CI environment
        const ciAgent = `${ciEnv.name.toUpperCase().replace(/\s+/g, '_')}_AGENT`;
        const initResult = await execTaskManagerCommand('initialize', [
          ciAgent,
        ]);
        expect(initResult.success).toBe(true);
        // Create environment-specific feature
        const envFeature = {
          title: `${ciEnv.name} Integration - Environment Detection`,
          description: `Feature for testing ${ciEnv.name} CI environment detection and adaptation`,
          business_value: `Ensures compatibility with ${ciEnv.name} CI/CD pipeline`,
          category: 'enhancement',
        };
        const featureResult = await execTaskManagerCommand('suggest-feature', [
          JSON.stringify(envFeature),
        ]);
        expect(featureResult.success).toBe(true);
        // Clean up environment variables
        Object.keys(ciEnv.env).forEach((key) => {
          delete process.env[key];
        });
        console.log(`${ciEnv.name} environment detection completed`);
      }
    });
    it('should support parallel CI job coordination', async () => {
      process.env.CI = 'true';
      process.env.CI_PARALLEL_JOBS = '4';
      process.env.CI_JOB_INDEX = '1';
      const parallelAgents = [
        'CI_PARALLEL_AGENT_1',
        'CI_PARALLEL_AGENT_2',
        'CI_PARALLEL_AGENT_3',
        'CI_PARALLEL_AGENT_4',
      ];
      const initPromises = parallelAgents.map((agentId) =>
        execTaskManagerCommand('initialize', [agentId]),
      );
      const initResults = await Promise.allSettled(initPromises);
      const successfulInits = initResults.filter(
        (r) => r.status === 'fulfilled' && r.value.success,
      );
      expect(successfulInits.length).toBe(parallelAgents.length);
      // Create multiple features for parallel processing
      const parallelFeatures = [];
      for (let i = 0; i < 8; i++) {
        const feature = {
          title: `Parallel CI Feature ${i + 1}`,
          description: `Feature ${i + 1} designed for parallel CI job processing and coordination testing`,
          business_value: `Enables parallel processing capability validation feature ${i + 1}`,
          category: i % 2 === 0 ? 'enhancement' : 'new-feature',
        };
        const result = await execTaskManagerCommand('suggest-feature', [
          JSON.stringify(feature),
        ]);
        if (result.success) {
          parallelFeatures.push(result.feature);
        }
      }
      expect(parallelFeatures.length).toBe(8);
      // Bulk approve for parallel processing
      const featureIds = parallelFeatures.map((f) => f.id);
      const bulkApproveResult = await execTaskManagerCommand(
        'bulk-approve-features',
        [
          JSON.stringify(featureIds),
          JSON.stringify({ approved_by: 'parallel-ci-system' }),
        ],
      );
      expect(bulkApproveResult.success).toBe(true);
      expect(bulkApproveResult.approved_count).toBe(8);
      console.log('Parallel CI job coordination tested successfully');
    });
  });
  /**
   * Automated Test Orchestration
   * Tests automated test execution and coordination
   */
  describe('Automated Test Orchestration', () => {
    it('should orchestrate comprehensive test suite execution', async () => {
      console.log('Setting up automated test orchestration...');
      // Create test orchestration agent
      const orchestratorAgent = 'TEST_ORCHESTRATOR_AGENT';
      await execTaskManagerCommand('initialize', [orchestratorAgent]);
      // Define comprehensive test suite
      const testSuite = {
        title: 'Automated Test Orchestration - Full Suite Execution',
        description:
          'Complete test suite including unit tests, integration tests, performance tests, and end-to-end validation with automated orchestration',
        business_value:
          'Ensures comprehensive test coverage and automated quality assurance across all system components',
        category: 'enhancement',
        metadata: {
          test_types: ['unit', 'integration', 'performance', 'e2e'],
          orchestrated: true,
          automation_level: 'full',
        },
      };
      const suiteResult = await execTaskManagerCommand('suggest-feature', [
        JSON.stringify(testSuite),
      ]);
      expect(suiteResult.success).toBe(true);
      await execTaskManagerCommand('approve-feature', [suiteResult.feature.id]);
      // Generate orchestrated test tasks
      const taskGenResult = await execTaskManagerCommand(
        'generate-tasks-from-approved-features',
        [],
      );
      expect(taskGenResult.success).toBe(true);
      // Verify task queue has orchestration tasks
      const queueResult = await execTaskManagerCommand('get-task-queue', [
        JSON.stringify({ feature_id: suiteResult.feature.id }),
      ]);
      expect(queueResult.success).toBe(true);
      expect(queueResult.tasks.length).toBeGreaterThan(0);
      console.log(
        `Test orchestration setup: ${queueResult.tasks.length} tasks generated`,
      );
    });
    it('should handle test execution failure and recovery', async () => {
      console.log('Testing failure recovery mechanisms...');
      // Create test that simulates failure scenarios
      const failureTestFeature = {
        title: 'Test Failure Recovery - Automated Retry and Reporting',
        description:
          'Feature for testing automated failure detection, retry mechanisms, and comprehensive error reporting in CI/CD pipeline',
        business_value:
          'Improves system reliability and reduces false negatives in automated testing',
        category: 'enhancement',
      };
      const featureResult = await execTaskManagerCommand('suggest-feature', [
        JSON.stringify(failureTestFeature),
      ]);
      await execTaskManagerCommand('approve-feature', [
        featureResult.feature.id,
      ]);
      const taskResult = await execTaskManagerCommand(
        'create-task-from-feature',
        [featureResult.feature.id],
      );
      expect(taskResult.success).toBe(true);
      // Simulate task failure and recovery
      const failureUpdate = await execTaskManagerCommand(
        'update-task-progress',
        [
          taskResult.task.id,
          JSON.stringify({
            status: 'failed',
            progress_percentage: 50,
            notes: 'Simulated test failure for recovery testing',
            updated_by: 'failure-simulation-agent',
            metadata: { failure_reason: 'simulated', retry_count: 0 },
          }),
        ],
      );
      expect(failureUpdate.success).toBe(true);
      expect(failureUpdate.task.status).toBe('failed');
      // Simulate recovery attempt
      const recoveryUpdate = await execTaskManagerCommand(
        'update-task-progress',
        [
          taskResult.task.id,
          JSON.stringify({
            status: 'in_progress',
            progress_percentage: 75,
            notes: 'Retrying after failure - recovery attempt initiated',
            updated_by: 'recovery-agent',
            metadata: { retry_count: 1, recovery_attempted: true },
          }),
        ],
      );
      expect(recoveryUpdate.success).toBe(true);
      expect(recoveryUpdate.task.status).toBe('in_progress');
      // Complete recovery
      const completionUpdate = await execTaskManagerCommand(
        'update-task-progress',
        [
          taskResult.task.id,
          JSON.stringify({
            status: 'completed',
            progress_percentage: 100,
            notes: 'Task completed successfully after recovery',
            updated_by: 'recovery-agent',
          }),
        ],
      );
      expect(completionUpdate.success).toBe(true);
      expect(completionUpdate.task.status).toBe('completed');
      console.log('Failure recovery testing completed successfully');
    });
    it('should generate comprehensive test reports', async () => {
      console.log('Generating comprehensive test reports...');
      // Create multiple test scenarios for reporting
      const testScenarios = [
        {
          name: 'Unit Test Coverage',
          category: 'enhancement',
          priority: 'high',
        },
        {
          name: 'Integration Test Suite',
          category: 'new-feature',
          priority: 'high',
        },
        {
          name: 'Performance Benchmarks',
          category: 'performance',
          priority: 'normal',
        },
        {
          name: 'Security Test Validation',
          category: 'security',
          priority: 'critical',
        },
      ];
      const testResults = [];
      for (const scenario of testScenarios) {
        const feature = {
          title: `Test Report - ${scenario.name}`,
          description: `Comprehensive ${scenario.name.toLowerCase()} with detailed reporting and metrics collection`,
          business_value: `Provides detailed insights into ${scenario.name.toLowerCase()} results and system quality`,
          category: scenario.category,
        };
        const featureResult = await execTaskManagerCommand('suggest-feature', [
          JSON.stringify(feature),
        ]);
        if (featureResult.success) {
          await execTaskManagerCommand('approve-feature', [
            featureResult.feature.id,
          ]);
          const taskResult = await execTaskManagerCommand(
            'create-task-from-feature',
            [
              featureResult.feature.id,
              JSON.stringify({ priority: scenario.priority }),
            ],
          );
          if (taskResult.success) {
            // Simulate test execution and completion
            await execTaskManagerCommand('update-task-progress', [
              taskResult.task.id,
              JSON.stringify({
                status: 'completed',
                progress_percentage: 100,
                notes: `${scenario.name} completed with comprehensive reporting`,
                updated_by: 'test-report-agent',
                metadata: {
                  test_type: scenario.name.toLowerCase().replace(/\s+/g, '_'),
                  report_generated: true,
                  timestamp: new Date().toISOString(),
                },
              }),
            ]);
          }
          testResults.push({ scenario: scenario.name, success: true });
        }
      }
      // Generate comprehensive statistics report
      const finalStats = await execTaskManagerCommand('feature-stats', []);
      expect(finalStats.success).toBe(true);
      const completedTasks = await execTaskManagerCommand('get-task-queue', [
        JSON.stringify({ status: 'completed' }),
      ]);
      console.log('Test Report Summary:');
      console.log(`  Total test scenarios: ${testResults.length}`);
      console.log(
        `  Completed tasks: ${completedTasks.success ? completedTasks.tasks.length : 0}`,
      );
      console.log(
        `  Feature statistics: ${finalStats.stats.total} features processed`,
      );
      expect(testResults.length).toBe(testScenarios.length);
    });
  });
  /**
   * Deployment Pipeline Integration
   * Tests automated deployment and release management
   */
  describe('Deployment Pipeline Integration', () => {
    it('should integrate with automated deployment workflows', async () => {
      console.log('Testing deployment pipeline integration...');
      // Simulate deployment environment
      process.env.DEPLOYMENT_ENVIRONMENT = 'staging';
      process.env.DEPLOY_VERSION = '1.2.3';
      process.env.DEPLOY_TARGET = 'autonomous-task-system';
      const deployAgent = 'DEPLOYMENT_AGENT';
      await execTaskManagerCommand('initialize', [deployAgent]);
      // Create deployment-specific features
      const deploymentFeatures = [
        {
          title: 'Deployment Pipeline - Staging Environment Setup',
          description:
            'Automated staging environment deployment with health checks, rollback capabilities, and monitoring integration',
          business_value:
            'Enables safe and reliable staging deployments with automated validation',
          category: 'enhancement',
        },
        {
          title: 'Deployment Pipeline - Production Release Automation',
          description:
            'Automated production deployment with canary releases, blue-green deployment, and comprehensive monitoring',
          business_value:
            'Provides zero-downtime production deployments with automated rollback on failure',
          category: 'new-feature',
        },
      ];
      const deploymentTasks = [];
      for (const feature of deploymentFeatures) {
        const featureResult = await execTaskManagerCommand('suggest-feature', [
          JSON.stringify(feature),
        ]);
        expect(featureResult.success).toBe(true);
        await execTaskManagerCommand('approve-feature', [
          featureResult.feature.id,
        ]);
        const taskResult = await execTaskManagerCommand(
          'create-task-from-feature',
          [
            featureResult.feature.id,
            JSON.stringify({
              created_by: deployAgent,
              metadata: {
                deployment_environment: process.env.DEPLOYMENT_ENVIRONMENT,
                version: process.env.DEPLOY_VERSION,
                target: process.env.DEPLOY_TARGET,
              },
            }),
          ],
        );
        if (taskResult.success) {
          deploymentTasks.push(taskResult.task);
        }
      }
      expect(deploymentTasks.length).toBe(deploymentFeatures.length);
      // Simulate deployment execution
      for (const task of deploymentTasks) {
        await execTaskManagerCommand('update-task-progress', [
          task.id,
          JSON.stringify({
            status: 'completed',
            progress_percentage: 100,
            notes:
              'Deployment completed successfully with all health checks passing',
            updated_by: deployAgent,
            metadata: { deployment_success: true, health_checks_passed: true },
          }),
        ]);
      }
      console.log('Deployment pipeline integration completed');
      // Clean up deployment environment variables
      delete process.env.DEPLOYMENT_ENVIRONMENT;
      delete process.env.DEPLOY_VERSION;
      delete process.env.DEPLOY_TARGET;
    });
    it('should handle deployment rollback scenarios', async () => {
      console.log('Testing deployment rollback scenarios...');
      const rollbackAgent = 'ROLLBACK_AGENT';
      await execTaskManagerCommand('initialize', [rollbackAgent]);
      // Create rollback scenario feature
      const rollbackFeature = {
        title: 'Deployment Rollback - Automated Failure Recovery',
        description:
          'Automated rollback system with health monitoring, traffic switching, and comprehensive logging for failed deployments',
        business_value:
          'Minimizes downtime and ensures system reliability during deployment failures',
        category: 'security', // High priority for system stability
      };
      const featureResult = await execTaskManagerCommand('suggest-feature', [
        JSON.stringify(rollbackFeature),
      ]);
      await execTaskManagerCommand('approve-feature', [
        featureResult.feature.id,
      ]);
      const taskResult = await execTaskManagerCommand(
        'create-task-from-feature',
        [featureResult.feature.id],
      );
      expect(taskResult.success).toBe(true);
      // Simulate deployment failure requiring rollback
      const failureUpdate = await execTaskManagerCommand(
        'update-task-progress',
        [
          taskResult.task.id,
          JSON.stringify({
            status: 'failed',
            progress_percentage: 80,
            notes:
              'Deployment failed health checks - initiating automated rollback',
            updated_by: rollbackAgent,
            metadata: {
              failure_reason: 'health_check_failure',
              rollback_initiated: true,
              previous_version: '1.2.2',
            },
          }),
        ],
      );
      expect(failureUpdate.success).toBe(true);
      expect(failureUpdate.task.status).toBe('failed');
      // Simulate successful rollback
      const rollbackUpdate = await execTaskManagerCommand(
        'update-task-progress',
        [
          taskResult.task.id,
          JSON.stringify({
            status: 'completed',
            progress_percentage: 100,
            notes:
              'Rollback completed successfully - system restored to previous stable version',
            updated_by: rollbackAgent,
            metadata: {
              rollback_completed: true,
              current_version: '1.2.2',
              rollback_duration_seconds: 45,
            },
          }),
        ],
      );
      expect(rollbackUpdate.success).toBe(true);
      expect(rollbackUpdate.task.status).toBe('completed');
      console.log('Deployment rollback testing completed');
    });
  });
  /**
   * Quality Gates and Compliance
   * Tests quality assurance and compliance validation
   */
  describe('Quality Gates & Compliance', () => {
    it('should enforce quality gates in CI pipeline', async () => {
      console.log('Testing quality gate enforcement...');
      const qualityAgent = 'QUALITY_GATE_AGENT';
      await execTaskManagerCommand('initialize', [qualityAgent]);
      // Define quality gate requirements
      const qualityGates = [
        { name: 'Code Coverage', threshold: 85, metric: 'percentage' },
        {
          name: 'Performance Benchmarks',
          threshold: 1000,
          metric: 'milliseconds',
        },
        {
          name: 'Security Scan',
          threshold: 0,
          metric: 'critical_vulnerabilities',
        },
        { name: 'Linting Compliance', threshold: 0, metric: 'violations' },
      ];
      // Create quality gate feature
      const qualityFeature = {
        title: 'Quality Gates - Automated Compliance Validation',
        description:
          'Comprehensive quality gate system with code coverage, performance benchmarks, security scanning, and linting compliance validation',
        business_value:
          'Ensures consistent code quality and compliance across all deployments',
        category: 'enhancement',
        metadata: {
          quality_gates: qualityGates,
          enforcement_level: 'strict',
          compliance_required: true,
        },
      };
      const featureResult = await execTaskManagerCommand('suggest-feature', [
        JSON.stringify(qualityFeature),
      ]);
      await execTaskManagerCommand('approve-feature', [
        featureResult.feature.id,
      ]);
      const taskResult = await execTaskManagerCommand(
        'create-task-from-feature',
        [featureResult.feature.id],
      );
      expect(taskResult.success).toBe(true);
      // Simulate quality gate validation
      const gateResults = [];
      for (const gate of qualityGates) {
        // Simulate meeting quality requirements
        const passed = true; // In real implementation, this would be actual validation
        gateResults.push({
          gate: gate.name,
          passed,
          threshold: gate.threshold,
        });
      }
      const allGatesPassed = gateResults.every((result) => result.passed);
      // Update task based on quality gate results
      await execTaskManagerCommand('update-task-progress', [
        taskResult.task.id,
        JSON.stringify({
          status: allGatesPassed ? 'completed' : 'failed',
          progress_percentage: allGatesPassed ? 100 : 50,
          notes: `Quality gates ${allGatesPassed ? 'passed' : 'failed'} - ${gateResults.length} gates validated`,
          updated_by: qualityAgent,
          metadata: {
            quality_gates_results: gateResults,
            all_gates_passed: allGatesPassed,
            validation_timestamp: new Date().toISOString(),
          },
        }),
      ]);
      expect(allGatesPassed).toBe(true);
      console.log(
        `Quality gates validation: ${gateResults.length} gates checked, all passed: ${allGatesPassed}`,
      );
    });
    it('should generate compliance and audit reports', async () => {
      console.log('Generating compliance and audit reports...');
      const auditAgent = 'AUDIT_AGENT';
      await execTaskManagerCommand('initialize', [auditAgent]);
      // Create audit and compliance features
      const complianceFeature = {
        title: 'Compliance Reporting - Automated Audit Trail Generation',
        description:
          'Comprehensive compliance reporting with audit trails, security assessments, and regulatory compliance validation',
        business_value:
          'Ensures regulatory compliance and provides comprehensive audit trails for governance',
        category: 'security',
      };
      const featureResult = await execTaskManagerCommand('suggest-feature', [
        JSON.stringify(complianceFeature),
      ]);
      await execTaskManagerCommand('approve-feature', [
        featureResult.feature.id,
      ]);
      const taskResult = await execTaskManagerCommand(
        'create-task-from-feature',
        [featureResult.feature.id],
      );
      expect(taskResult.success).toBe(true);
      // Generate comprehensive compliance report data
      const complianceData = {
        audit_timestamp: new Date().toISOString(),
        system_version: '2.0.0',
        compliance_frameworks: ['SOC2', 'ISO27001', 'GDPR'],
        security_assessments: {
          vulnerability_scan: { status: 'passed', critical: 0, high: 0 },
          dependency_check: { status: 'passed', outdated: 0, vulnerable: 0 },
          code_analysis: { status: 'passed', issues: 0 },
        },
        quality_metrics: {
          code_coverage: 92.5,
          performance_benchmarks: { avg_response_time: 245 },
          test_results: { total: 156, passed: 156, failed: 0 },
        },
        access_controls: {
          authentication_enabled: true,
          authorization_validated: true,
          audit_logging: true,
        },
      };
      // Complete compliance task with comprehensive report
      await execTaskManagerCommand('update-task-progress', [
        taskResult.task.id,
        JSON.stringify({
          status: 'completed',
          progress_percentage: 100,
          notes: 'Compliance audit completed - all requirements satisfied',
          updated_by: auditAgent,
          metadata: {
            compliance_report: complianceData,
            report_generated: true,
            all_checks_passed: true,
          },
        }),
      ]);
      // Verify audit trail exists
      const stats = await execTaskManagerCommand('feature-stats', []);
      expect(stats.success).toBe(true);
      console.log('Compliance and audit reporting completed');
    });
  });
  /**
   * Utility function to execute task manager commands
   */
  async function execTaskManagerCommand(command, args = []) {
    return new Promise((resolve, reject) => {
      const child = spawn(
        'timeout',
        ['10s', 'node', taskManagerPath, command, ...args],
        {
          cwd: rig.testDir,
          stdio: 'pipe',
        },
      );
      let stdout = '';
      let stderr = '';
      child.stdout?.on('data', (data) => {
        stdout += data.toString();
      });
      child.stderr?.on('data', (data) => {
        stderr += data.toString();
      });
      child.on('close', (code) => {
        if (code === 0) {
          try {
            const result = JSON.parse(stdout);
            resolve(result);
          } catch {
            reject(
              new Error(`Failed to parse JSON: ${stdout.substring(0, 200)}...`),
            );
          }
        } else {
          reject(
            new Error(
              `Command '${command}' failed with code ${code}: ${stderr || stdout}`,
            ),
          );
        }
      });
      child.on('error', (error) => {
        reject(
          new Error(`Failed to execute command '${command}': ${error.message}`),
        );
      });
      setTimeout(() => {
        child.kill('SIGKILL');
        reject(new Error(`Command '${command}' timeout after 15 seconds`));
      }, 15000);
    });
  }
});
//# sourceMappingURL=ci-cd-automation.test.js.map
